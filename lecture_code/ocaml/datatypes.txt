if true then false else true;;
[1;2;3];;
[1;2;3;4];;
[1.-;2.3;4.5];;
[1.;2.3;4.5];;
[1;true];;
[if true then false else true];;
[if true then false else true;true];;
[fun x -> x + 1;fun x -> x  * 2];;
[fun x -> x + 1];;
[fun x -> x + 1;(fun x -> x * 2);];;
[(fun x -> x + 1);(fun x -> x * 2);];;
(3,4);;
(3,4.6);;
[1];;
[1;2;3];;
[1;2;3] = [1];;
(3,2) = (2,3,4);;
(1,2,3);;
[(1,2);(1,3)];;
[(1,2);(1,3,3)];;
[(1,2.3);(1,3)];;
let a = (1,2.3) in match a with \n(x,y) -> y;;
let a = (1,2.3) in match a with \n(x,y) -> x;;
let foo x = match x with\n(x,y) -> if x then y else 3 in foo;;
let foo x = match x with\n(x,y) -> if false then y else 3 in foo;;
let foo x = match x with\n(z,y) -> if z then y else 3 in foo;;
let foo x y = match x with\n(z,y) -> if z then y else 3 in foo;;
let foo x y = match x with\n(z,y,a) -> if z then y else 3 in foo;;
let foo x y = match x with\n(z,y,a) -> if z then y else 3\n|(c,d) -> 4 in foo;;
let foo x = match x with\n3 -> "a"\nh::t -> "b";;
let foo x = match x with\n  3 -> "a"\n  |h::t -> "b";;
let foo x = match x with\n  [] -> "a"\n  |3 -> "b";;
type Color = blue | red;;
type color = Blue | Red;;
Blue;;
Red;;
let swap c = match c with\n  Blue -> Red\n  |Red -> Blue;;
swap Blue;;
swap Red;;
swap swap swap Red;;
swap (swap (swap Red));;
swap (swap (Red));;
type coin = Heads | Tails | Edge;;
let flip x = if x mod 3 = 1 then Heads else if x mod 3 = 0 then Tails else Edge;;
flip 1;;
flip 2;;
flip 3;;
[1;2;3];;
[1.;2.;3.];;
[1.;2.;3.;3];;
type num = Int of int | Float of float;;
Num(3);;
num(3);;
Int(3);;
Float(4.3);;
[Int(3);Float(2.3)];;
2.3 = Float(2.3);;
let f_of_i x = match x with\nInt(a) -> Float(float_of_int a)\n|_ -> failwith "Expected type Int";;
f_of_i Int(3);;
f_of_i (Int(3));;
f_of_i (Float(3.3));;
(fun x -> 2::x);;
(fun x -> 2::x) [3;4;5];;
(fun x -> 2::x) [Int(3);Float(2.3)];;
let int_of_num x = match x with Int(a) -> a|_ -> failwith "expected Int";;
int_of_num Int(3);;
int_of_num (Int(3));;
int_of_num (Float(3));;
int_of_num (Float(3.));;
type tree = Leaf|Node of tree * int * tree ;;
let rec count t = match t with\n  Leaf -> 0\n  |Node(l,c,r) -> (count l) + (count r) + 1;;
let t1 = Node(Node(Node(Leaf,4,Leaf),2,Leaf),1,Node(Leaf,3,Leaf));;
count t1;;
let rec mirror t = match t with\n  Leaf -> Leaf\n  |Node(l,c,r) -> Node(mirro r,c,mirror l);;
let rec mirror t = match t with\n  Leaf -> Leaf\n  |Node(l,c,r) -> Node(mirror r,c,mirror l);;
mirror t1;;
let sumnode t = match t with \n  Leaf -> 0\n  |Node(l,c,r) -> c + sumnode l + sumnode r;;
let rec sumnode t = match t with \n  Leaf -> 0\n  |Node(l,c,r) -> c + sumnode l + sumnode r;;
sumnode t1;;
type transition = Trans of int * string * int;;
type nfa = char list * int list * int * int list * transition list;;
let x = 3 in x + 3;;
